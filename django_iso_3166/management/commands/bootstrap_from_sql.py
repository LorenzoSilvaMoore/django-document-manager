from django.core.management.base import BaseCommand
from django.db import connection, transaction
from django.conf import settings
import os
from pathlib import Path

class Command(BaseCommand):
    help = 'Bootstrap the geographic data from SQL file into the database'

    def add_arguments(self, parser):
        parser.add_argument(
            '--sql-file',
            type=str,
            help='Path to the SQL file (defaults to data/example_world.sql)',
            default=None,
        )
        parser.add_argument(
            '--skip-drop-tables',
            action='store_true',
            help='Skip dropping existing tables (useful for updates)',
        )
        parser.add_argument(
            '--dry-run',
            action='store_true',
            help='Show what would be executed without running it',
        )

    def handle(self, *args, **options):
        # Get the path to the SQL file
        if options['sql_file']:
            sql_file_path = Path(options['sql_file'])
        else:
            # Default to the SQL file in the data directory
            current_dir = Path(__file__).parent.parent.parent
            sql_file_path = current_dir / 'data' / 'example_world.sql'

        if not sql_file_path.exists():
            self.stdout.write(
                self.style.ERROR(f'SQL file not found: {sql_file_path}')
            )
            return

        self.stdout.write(
            self.style.SUCCESS(f'Reading SQL file: {sql_file_path}')
        )

        # Read the SQL file
        try:
            with open(sql_file_path, 'r', encoding='utf-8') as f:
                sql_content = f.read()
        except Exception as e:
            self.stdout.write(
                self.style.ERROR(f'Error reading SQL file: {e}')
            )
            return

        # Process the SQL content
        sql_statements = self.process_sql_content(sql_content, options['skip_drop_tables'])

        if options['dry_run']:
            self.stdout.write(self.style.WARNING('DRY RUN MODE - No changes will be made'))
            for i, statement in enumerate(sql_statements, 1):
                self.stdout.write(f"\n--- Statement {i} ---")
                self.stdout.write(statement[:200] + '...' if len(statement) > 200 else statement)
            return

        # Execute the SQL statements
        self.execute_sql_statements(sql_statements)

    def process_sql_content(self, sql_content, skip_drop_tables=False):
        """Process the SQL content and return a list of statements to execute"""
        
        # Split the content into individual statements
        statements = []
        current_statement = []
        
        lines = sql_content.split('\n')
        
        for line in lines:
            line = line.strip()
            
            # Skip comments and empty lines
            if not line or line.startswith('--') or line.startswith('/*'):
                continue
                
            # Skip PostgreSQL specific commands that don't apply to Django/SQLite
            postgres_skip_patterns = [
                'SET statement_timeout',
                'SET lock_timeout',
                'SET idle_in_transaction_session_timeout',
                'SET client_encoding',
                'SET standard_conforming_strings',
                'SELECT pg_catalog.set_config',
                'SET check_function_bodies',
                'SET xmloption',
                'SET client_min_messages',
                'SET row_security',
                'SET default_tablespace',
                'SET default_table_access_method',
                'ALTER TABLE',
                'DROP INDEX',
                'DROP TABLE',
                'DROP CONSTRAINT',
                'CREATE INDEX',
                'ADD CONSTRAINT',
                'COMMENT ON',
                'ALTER COLUMN',
                'ADD GENERATED BY DEFAULT AS IDENTITY',
                'SELECT pg_catalog.setval',
            ]
            
            # Skip PostgreSQL specific lines
            should_skip = any(line.upper().startswith(pattern.upper()) for pattern in postgres_skip_patterns)
            
            if skip_drop_tables and line.upper().startswith('DROP TABLE'):
                should_skip = True
                
            if should_skip:
                continue
            
            current_statement.append(line)
            
            # If line ends with semicolon, it's the end of a statement
            if line.endswith(';'):
                statement = ' '.join(current_statement)
                if statement.strip():
                    statements.append(statement)
                current_statement = []
        
        # Filter and adapt statements for Django/SQLite
        adapted_statements = []
        
        for statement in statements:
            adapted = self.adapt_sql_for_django(statement)
            if adapted:
                adapted_statements.append(adapted)
        
        return adapted_statements

    def adapt_sql_for_django(self, statement):
        """Adapt PostgreSQL SQL to work with Django/SQLite"""
        
        statement = statement.strip()
        
        # Skip CREATE TABLE statements - Django migrations handle this
        if statement.upper().startswith('CREATE TABLE'):
            return None
            
        # Only process INSERT statements
        if not statement.upper().startswith('INSERT INTO'):
            return None
            
        # Adapt table names to Django's convention (add app prefix if needed)
        table_mappings = {
            'public.regions': 'django_iso_3166_region',
            'public.subregions': 'django_iso_3166_subregion', 
            'public.countries': 'django_iso_3166_country',
            'public.states': 'django_iso_3166_state',
            'public.cities': 'django_iso_3166_city',
        }
        
        for pg_table, django_table in table_mappings.items():
            statement = statement.replace(pg_table, django_table)
        
        return statement

    def execute_sql_statements(self, statements):
        """Execute SQL statements with proper transaction handling"""
        
        self.stdout.write(
            self.style.SUCCESS(f'Executing {len(statements)} SQL statements...')
        )
        
        try:
            with transaction.atomic():
                with connection.cursor() as cursor:
                    for i, statement in enumerate(statements, 1):
                        try:
                            self.stdout.write(f'Executing statement {i}/{len(statements)}...')
                            cursor.execute(statement)
                            
                        except Exception as e:
                            self.stdout.write(
                                self.style.ERROR(f'Error in statement {i}: {e}')
                            )
                            self.stdout.write(f'Statement: {statement[:200]}...')
                            raise
                            
            self.stdout.write(
                self.style.SUCCESS('✅ All SQL statements executed successfully!')
            )
            
        except Exception as e:
            self.stdout.write(
                self.style.ERROR(f'❌ Transaction failed: {e}')
            )
            raise
